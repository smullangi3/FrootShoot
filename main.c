#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/startBackground.h"
#include "images/playBackground.h"
#include "images/shotMarkImage.h"
#include "images/fruitImage.h"
#include "images/fruitSplatImage.h"


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  STARTBRIDGE,
  PLAY,
  END,
  GAMEOVER
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  player user = {.row = HEIGHT/2, .col = WIDTH/2, .speed = 4, .score = 0}; //user's position and point data
  int timer = 60;

  //layout
  char infobar[70];
  char endCard[70];
  //shots
  struct shotMark shots[30]; //shots already fired
  unsigned int shotsSize = 0;

  //fruits
  struct fruit fruits[100];
  unsigned int fruitsSize = 0;

  //fruitSplats
  struct fruitSplat fruitSplats[100];
  unsigned int fruitSplatsSize = 0;

  char *title = "FROOTSHOOT - click A or Start";

  enum gba_state state = START;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    //u32 edgeTrigger = (previousButtons | currentButtons); //for each place, sets to 0 if pressed now and not previously, 1 otherwise
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
      state = START;
    }

    switch (state) {
      case START:
        //resetting functionality
        shotsSize = 0;
        fruitsSize = 0;
        fruitSplatsSize = 0;
        user.row = HEIGHT/2;
        user.col = WIDTH/2;
        user.speed = 4; 
        user.score = 0;
        timer = 60;
        drawFullScreenImageDMA(startBackground);

        state = STARTBRIDGE;
        break;
      case STARTBRIDGE:
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons) || KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(playBackground);
          drawRectDMA(0, 0, WIDTH, 8, BLACK);
          sprintf(infobar, "Score: %d, Ammo: %d, Time: %d", user.score, (30 - shotsSize), timer);
          drawString(0,0, infobar, WHITE);
          state = PLAY;
          break;
        }

        drawString(0, 0, title, WHITE);
        break;
      case PLAY:
        if (vBlankCounter % 60 == 0) {
          timer--;
          
          //update the infobar
          drawRectDMA(0, 0, WIDTH, 8, BLACK);
          sprintf(infobar, "Score: %d, Ammo: %d, Time: %d", user.score, (30 - shotsSize), timer);
          drawString(0,0, infobar, WHITE);
        }
        if (timer <= 0) {
          state = END;
          break;
        }

        //undo previous crosshairs
        undrawImageDMA(user.row, user.col + 4, 1, 9, playBackground);
        undrawImageDMA(user.row + 4, user.col, 9, 1, playBackground);
        
      
        //update user's crosshairs
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          user.col -= user.speed;
          if (user.col < 0) {
            user.col = 1;
          }
        } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          user.col += user.speed;
          if (user.col > (WIDTH - 9)) {
            user.col = WIDTH - 10;
          }
        }

        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          user.row -= user.speed;
          if (user.row < 8) {
            user.row = 8;
          }
        } else if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          user.row += user.speed;
          if (user.row > (HEIGHT - 9)) {
            user.row = HEIGHT - 9;
          }
        }

        //bullets
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
          shots[shotsSize].row = user.row;
          shots[shotsSize].col = user.col;


          for (unsigned int i = 0; i < fruitsSize; i++) {
            //if the bullet shot collides with the fruit
            if (fruits[i].toRender && collides(shots[shotsSize].row, shots[shotsSize].col, 9, 9, fruits[i].row, fruits[i].col, 16, 16)) {
              fruits[i].toRender = 0;
              undrawImageDMA(fruits[i].row, fruits[i].col, 16, 16, playBackground);
              
              fruitSplats[fruitSplatsSize].row = fruits[i].row;
              fruitSplats[fruitSplatsSize].col = fruits[i].col;
              fruitSplatsSize++;

              user.score += 1;
              
            }
          }

          shotsSize++;
          if (shotsSize >= 30) {
            state = END;
            break;
          }

          //update the infobar
          drawRectDMA(0, 0, WIDTH, 8, BLACK);
          sprintf(infobar, "Score: %d, Ammo: %d, Time: %d", user.score, (30 - shotsSize), timer);
          drawString(0,0, infobar, WHITE);
        }

        //draw bulletholes
        for (unsigned int i = 0; i < shotsSize; i++) {
          drawImageDMA(shots[i].row, shots[i].col, 9, 9, shotMarkImage);
        }

        //draw fruitsplats
        for (unsigned int i = 0; i < fruitSplatsSize; i++) {
          drawImageDMA(fruitSplats[i].row, fruitSplats[i].col, 16, 16, fruitSplatImage);

        }

        //add a fruit randomly every second
        if (vBlankCounter % 60 == 0) {
          fruits[fruitsSize].col = randint(WIDTH/8, 7*WIDTH/8);
          fruits[fruitsSize].row = HEIGHT;
          fruits[fruitsSize].vel_y = randint(3, 7);
          fruits[fruitsSize].vel_x = randint(0, 5);
          if (randint(0, 2)) {
            fruits[fruitsSize].vel_x *= -1;
          }
          fruits[fruitsSize].toRender = 1;

          fruitsSize++;
        }

        for (unsigned int i = 0; i < fruitsSize; i++) {
          if (fruits[i].toRender == 1) {
          //update fruits
          undrawImageDMA(fruits[i].row, fruits[i].col, 16, 16, playBackground);
          if (vBlankCounter % Gi == 0) {
            fruits[i].vel_y -= 1;
          }
          fruits[i].row -= fruits[i].vel_y;
          fruits[i].col += fruits[i].vel_x;
          if (fruits[i].vel_y < 0 && fruits[i].row > HEIGHT) {
            fruits[i].toRender = 0;
          } else if (fruits[i].vel_x < 0 && fruits[i].col < 0) {
            fruits[i].vel_x *= -1;
          } else if (fruits[i].vel_x > 0 && fruits[i].col > WIDTH - 16) {
            fruits[i].vel_x *= -1;
          }

          //render fruits
            drawImageDMA(fruits[i].row, fruits[i].col, 16, 16, fruitImage);
          }
        }

        

        //render crosshairs
        drawRectDMA(user.row, user.col + 4, 1, 9, WHITE);
        drawRectDMA(user.row + 4, user.col, 9, 1, WHITE);

        
        // state = ?
        break;
      case END:
        fillScreenDMA(BLACK);
        state = GAMEOVER;
        // state = ?
        break;
      case GAMEOVER:
        sprintf(endCard, "Final Score: %d", user.score);
        drawCenteredString(0, 0, WIDTH, HEIGHT/2, "Game Over", WHITE);
        drawCenteredString(0, 0, WIDTH, HEIGHT, endCard, WHITE);
        drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, "Click A or Start to Play Again", WHITE);

        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons) || KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}

int collides(int r1, int c1, int w1, int h1, int r2, int c2, int w2, int h2) {
  //check first corner
  if (c1 >= c2 && c1 <= (c2+w2) && r1 >= r2 && r1 <= (r2 + h2)) {
    return 1;
  }
  if (c1 + w1 >= c2 && c1 + w1 <= (c2+w2) && r1 >= r2 && r1 <= (r2 + h2)) {
    return 1;
  }
  if (c1 >= c2 && c1 <= (c2+w2) && r1 + h1 >= r2 && r1 + h1 <= (r2 + h2)) {
    return 1;
  }
  if (c1 + w1 >= c2 && c1 + w1 <= (c2+w2) && r1 + h1 >= r2 && r1 + h1 <= (r2 + h2)) {
    return 1;
  }
  return 0;
}

